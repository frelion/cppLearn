# 多态

虚函数是c++实现多态的一种手段，通过虚函数利用复写实现多态

## 多态
### 多态的定义
一句话版本：
父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作

详细版本：
所谓多态，就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行时确定，即一个引用变量到底会指向哪个类的实例对象，调用哪个类的实现方法，由程序运行期间才确定，这样不用修改程序源代码就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

总结：
1. 引用的变量类型和调用的具体方法在编程期间不确定，在程序运行期间或者编译期间才确定
2. 可通过让引用变量绑定在不同的类实现上，从而达到不修改程序代码就改变程序运行时所绑定的具体代码，使得程序可以选择多个运行状态

### 多态的好处
1. 一个接口，多种实现。便于模块的修改扩充
2. 继承父类接口，只对部分代码重写，减少代码冗余
3. 增加了软件设计编程的灵活性
4. 各个类层次的功能使用同一个名字，便于理解
5. 泛型编程，极大方便开发

## 虚函数（运行时确定类型）
虚函数是实现多态的重要工具

基本上可以把虚函数理解成为接口

### 虚函数的工作原理
**编译器必须生成程序运行时能够选择正确实例方法的代码！**

具体做法：

当类中存在虚函数时，编译器默认会给对象添加一个隐藏成员。该成员为一个指向虚函数表的指针。
（每个包含虚函数的实例都会有自己的一个虚函数表）

虚函数表是一个保存了虚函数地址的数组。编译器会检查类中所有的虚函数，依次将每个虚函数的地址，存入虚函数表

简而言之，虚函数表中存储了所有实际的函数，当我们用父类的指针操作子类，调用函数时，会去虚函数表查询找到真正的实例函数

### 虚函数表

示例一（未曾重写）：
```cpp
class Entity{
    public:
    virtual void func1(){

    }
}
class Ball : public Entity{
    virtual void func2(){

    }
}
/*
虚函数表：
[Entity:func1 -> Ball:func1]
因为Ball是Entity的子类，func2是Ball新定义的虚函数，因此排在Entity定义的虚函数的后面

又因为Ball并没有对Entity：func1进行重写，所以Ball的虚函数表最前面还是Entity:func1
*/
```
示例二（已重写）：
```cpp
class Entity{
    public:
    virtual void func1(){

    }
}
class Ball : public Entity{
    virtual void func1(){

    }
    virtual void func2(){

    }
}
/*
虚函数表：
[Ball:func1] -> [Entuty:func2]
因为，Ball这里对Entity进行了重写，所以虚函数表中原本Entity:func1的位置就被Ball:func1取代了！
*/
```
示例三（多重继承，无重写）：

示例三（多重继承，有重写）：

### 纯虚函数
纯虚函数就是父类中没有给出实现的虚函数，完全交给继承他的子类来实现

- 纯虚函数：没有函数体的虚函数
- 抽象类：包含纯虚函数的类

1. 当在基类中不能为虚函数给出一个有意义的实现时，可以将其声明为纯虚函数，其实现留待派生类完成。

2. 纯虚函数的作用是为派生类提供一个一致的接口。
3. 纯虚函数不能实例化，但可以声明指针。
4. 抽象类不能被用于实例化对象，它只能作为接口使用。
5. 如果子类中不实现纯虚函数，子类也会变成抽象类

```cpp
class Entity{
    public:
    virtual void func1() = 0;
}
class Ball : public Entity{
    virtual void func1(){
        
    }
}
```
### 析构函数与虚函数
**析构函数一定要定义为虚函数，除非这个函数不会被当作基类！**
1. 由虚函数表知，如果子类没有定义实现虚函数，那么析构函数将会调用父类虚构函数，这样子类的一些堆分配的变量就得不到释放，导致内存泄漏
2. 子类实现的虚构函数一定会调用父类的虚构函数，释放父类对象，保证内存安全释放
3. 析构函数的调用顺序为先调用自己的析构函数，然后再调用父类的析构函数，再调用父类的父类的析构函数。自下往上

### 构造函数与虚函数
**构造函数绝对不能是虚函数**
1. 存储上：虚函数表存储在每个实例中，构造函数是虚函数的话，实例都还没创建完，怎么挂载虚函数
2. 使用上：虚函数主要为了满足我们不知道在某种场合下这个函数会做什么而设计的，但是构造函数的调用我们都很明确地知道我们要初始化什么，因此没必要
### 泛型编程（编译时确定类型）